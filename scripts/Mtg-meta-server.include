#
# Variables:
#
# promo.booster{set} - remaining booster cards to give as prizes

#
# CONSTANTS
# =========

if(!port)
  port=29100;

factory.port=29101;

INITIAL_MONEY=50.0;
GAME_BONUS=13.0;
BET_BONUS_MULTIPLIER=1;
LOSER_PERCENTAGE=0.2;
DRAW_PERCENTAGE=0.4;
PLAYSET_COUNT=4;
DRAFT_MIN_PLAYERS=2;
DRAFT_MAX_PLAYERS=8;
# Number of packs per player used in a typical draft
DRAFT_DEFAULT_PRODUCTS=3;
DRAFT_MAX_PRODUCTS=6;

cubecontents=(,);

CUBES=(,);

CUBES{"Holiday"}=(22687,11109,22542,17475,20295,16442,12119,16839,17036,22037,22592,20846,16204,18271,17611,18930,19867,17139,20722,20442,22208,22231,23292,22548,22360,15858,17021,15192,18466,19862,16497,19651,19777,9482,22386,18944,23228,23271,19856,16480,19677,17716,20158,17242,6353,13445,19760,21523,22947,13162,22829,20674,21052,21390,18226,23360,21046,17674,6704,20703,2608,17741,17450,20880,23311,12221,1982,21240,20297,17926,20362,13139,17792,18085,20412,21204,19765,16212,16951,20673,23397,19704,14332,13702,19742,23297,19781,16989,22218,21239,16598,19073,21178,18500,23382,17234,15334,21040,21375,8339,17213,6470,16029,21069,22927,7484,3932,21206,23288,23330,21144,19822,23207,21415,19701,21339,21142,21170,23331,21895,12950,17181,17798,16652,21330,22154,6038,21331,6245,10036,21213,6072,21342,22082,21094,8445,6926,21871,21256,15833,20887,23211,15874,21212,17485,11186,14292,19106,6133,18191,15667,19969,20550,20678,17891,8774,19003,22302,17235,16916,23324,22356,22842,22227,17041,22603,22515,17259,18394,19826,18005,22936,15854,8845,21344,22946,17014,3791,22881,22926,23220,20191,14260,21990,22706,6669,16329,23060,20319,21113,21175,17344,21357,13391,21324,23005,18117,2638,21042,23183,3962,21227,23061,1988,2068,21356,20171,15879,22224,17737,5026,21985,18097,22894,20915,19044,16340,18423,21811,20097,22453,19888,22183,20472,6668,13623,17767,20980,12960,22206,18209,17022,23277,15760,20303,18906,18535,20482,19708,21588,22165,16834,22027,23194,4549,23283,17875,17744,21687,20216,17512,16189,18875,23628,21377,12168,12044,11283,21134,21079,22199,8854,19091,19778,21350,19678,21075,21886,23406,18318,21522,22556,6048,23365,18699,17882,17645,12215,22186,21146,16337,22266,23309,16552,15938,21273,21497,20026,20310,23379,23150,13347,20728,19685,22338,17588,21354,15697,15976,20258,17113,16466,20348,21114,12675,18905,22623,18533,23322,20364,18335,22402,19847,17959,17416,22217,18774,21719,19938,17138,21463,18547,20505,21081,19732,21263,19790,21126,20474,4781,14303,3132,17017,19827,16799,21133,23040,23122,21319,18545,11084,22370,6879,17962,22779,16962,19165,19175,23344,22697,20116,17111,21054,19122,18042,17580,19012,19130,18550,18216,22693,19277,20346,14190,15516,19610,19724,21456,19588,18263,19825,22088,8725,19001,21638,18942,19737,21470,21407,19832,23301,20783,18658,21395,19566,17401,19069,23227,19696,19246,15028,20381,19733,20623,18830,21948,22043,22091,19769,23281,23393,23229,23274,22614,21733,23361,6871,23284,21210,22369,16835,10423,22443,22295,10805,16979,21065,10396,23235,21199,19735,21205,23034,21218,21219,21220,21221,21222,3181,21208,19111,11238,22363,22368,12621,17339,17375,17422,6168,17426,10474,17448,17460,17497,10943,17515,5141,20604,17262,20612,11604,4479,20376,13555,13777,10974,16935,17108,19808,19809,17279,7593,19834,22441,22303,21299,22405,17136,18778,21211,16851,19622,13713,21041,23984,21051,23433,21059,21060,23985,23986,23987,23448,17908,18743,18744,23990,5885,18779,23991,13590,23992,17985,13595,17997,1950,21196,23553,20958,23993,2186,2639,21214,23994,19990,23995,21248,23996,7358,18870,23998,21278,23999,21282,14322,23621,24001,24002,21312,18100,14034,18897,21321,24004,21332,14060,21337,21338,14067,21341,21820,24005,21346,23149,23155,24006,24007,24008,18132,23680,);

CUBES{"Legacy"}=(16974,18944,19862,16497,19867,17139,20722,17903,19651,11052,23228,17694,15858,21125,9482,20442,22208,19298,22231,17021,22743,11109,23273,21182,15931,23547,17036,16357,22281,23292,22548,17475,17242,19117,15192,18466,19777,22037,22360,20295,22592,16442,18896,22386,18271,17611,19849,17630,20880,6319,20905,12221,13832,17741,17450,2608,23311,21240,20297,17310,21046,21390,17674,18365,18189,18226,22277,16391,6704,23360,18503,20703,22156,13445,19760,23326,22829,21523,20674,16480,19856,16779,19677,20158,17716,20362,21590,16989,20412,17926,20428,22218,19704,23519,23537,19721,19723,13139,21204,20218,19742,23018,23297,1375,19765,17792,17234,19781,22351,21287,18085,14332,21799,22860,18903,13292,20316,23397,13702,15018,21349,21094,21145,23002,8445,6926,12950,8783,22154,21111,17181,17798,16652,10962,6038,23135,21342,21375,10871,22927,23207,22164,7484,21895,22948,21610,20155,19924,21415,22968,17949,21142,8339,19701,3932,22247,23288,6188,23575,19756,23330,13966,23331,16029,22384,16598,19073,21178,18500,20099,22111,15833,21871,6133,9884,23211,23465,19003,22172,13790,20161,23485,15874,18191,23508,22227,18195,22228,18394,20774,15667,19728,23551,17041,23290,20225,22302,14292,20550,19106,17235,15374,17813,17259,22842,22356,16916,22603,22422,20678,21042,17321,23183,2865,23470,5843,3962,11995,23061,19202,20342,17344,21080,22478,13391,22178,22706,5866,21175,16329,23548,23005,23323,23600,23060,20319,20670,18117,22926,22936,15854,23220,19914,8845,17014,20191,22274,14260,21990,3791,19794,22881,18005,21688,17827,23413,21859,12960,22126,22132,23452,19888,16115,22183,19289,22206,22499,21632,15878,23510,15879,21645,19044,19708,17737,18209,6668,20482,22748,5026,23277,16344,18423,17767,23024,19744,21985,20980,20266,15760,23363,20303,22876,18906,20097,18535,22556,12734,6048,23365,20188,20106,18537,23180,18318,21079,21886,17930,23475,8854,16294,16300,23488,21937,18808,19091,18455,19778,22813,17097,20657,23194,23283,17744,21687,20216,18875,19416,21377,12168,16439,21798,17129,11283,16514,21588,16834,22027,20348,22634,18699,17882,20364,17645,14410,20728,18335,22681,21114,12215,22186,19685,16552,21146,21655,12675,16337,22266,13611,15938,23560,15697,23579,23309,16639,12879,15976,16392,20258,23322,22334,22338,21273,21497,20026,22867,20310,23379,22402,18905,17113,16466,20338,23150,13347,22623,21351,18533,22439,19847,23679,21354,14175,22370,21319,12770,17138,20401,21126,16124,18760,16799,17017,20474,19727,4781,23043,14303,23328,21263,19790,19827,18547,21593,22665,16038,22217,17959,17416,19938,18774,21719,20115,23178,21054,18550,19246,21374,19001,20422,22693,22694,22696,22697,21407,18179,20174,17962,19301,18216,20947,20784,19724,19083,23301,19366,18042,19769,21255,15516,23344,18658,19588,18097,19825,19832,19228,21456,19012,19737,19130,19175,8725,18942,20381,22704,23227,17401,19069,19733,21253,19165,17580,19613,15028,20116,19277,21638,20783,18830,19566,22049,16962,19211,20346,10423,23229,23518,23281,22295,21733,23321,22369,23361,10805,23393,22443,19625,20376,16094,17136,19642,18981,10396,13555,22934,19920,23235,18778,10905,20936,10474,17460,22270,22283,23034,20017,11238,23362,7593,22405,19834,4479,22441,23274,22614,13713,21041,23984,21051,23433,21059,23985,23986,23987,13752,23448,19650,17908,12817,18743,18744,23990,5885,18779,23991,23992,17985,17997,13871,23553,20958,23993,2639,23994,19990,20235,23995,21248,23996,21488,7358,18870,23998,21278,23999,21282,23621,24001,24002,18100,14034,18897,21321,22398,24004,20311,20312,20854,21019,21020,20855,20313,20856,20314,20315,19435,21337,21338,14067,21341,24005,21346,23149,24006,14384,24007,24008,18132,23680,);

ANONYMOUS_IP="www.wizards.com";

# Order in which bonus sets need to be filled out
REWARD_ORDER = ("UG","UH","P1","P2","P3","S1","COM","PC2","C13");

if(!load("products"))
{
  products=(,);
  products{"Beta booster"}=(50000,2.45,("BE","booster"),50000);
  products{"Beta starter"}=(50000,7.95,("BE","starter"),50000);
  products{"Arabian Nights booster"}=(50000,1.45,("AN","booster"),50000);
  products{"Antiquities booster"}=(50000,1.45,("AQ","booster"),50000);
  products{"Legends booster"}=(50000,2.45,("LG","booster"),50000);
  products{"The Dark booster"}=(50000,1.45,("DK","booster"),50000);
  products{"Fallen Empires booster"}=(50000,1.45,("FE","booster"),50000);
  save("products");
}

promo.booster = (,);

#
# HOOKS
# =====

# SealedStartHook(sealed player name,mode name,money,options) - This hook is called after
#   initialization of sealed mode is complete. Current user is a
#   player entering in the sealed mode. Note: This hook can be called more often than end hook.
#
def SealedStartHook
{
  check_card(ARG[0],1098);
  if(users{ARG[0]}[2]{1098}[0]==0)
  {
    Reply("Adding some lands...");
    AddCards(ARG[0],1098,45);
    AddCards(ARG[0],1135,45);
    AddCards(ARG[0],1175,45);
    AddCards(ARG[0],1201,45);
    AddCards(ARG[0],1254,45);
    Refresh(1098,1135,1175,1201,1254);
  }
}

#
# SealedStartCount() - Return number of cards that are automatically given to new sealed users.
#
def SealedStartCount
{
  return(225);
}

# SealedEndHook() - This hook is called before ending sealed
#   mode. Current user is sealed mode player.
#
def SealedEndHook
{
  check_card(User(),1098);
  if(users{User()}[2]{1098}[0] > 0)
  {
    Reply("Removing extra lands...");
    DelCards(User(),1098,45);
    DelCards(User(),1135,45);
    DelCards(User(),1175,45);
    DelCards(User(),1201,45);
    DelCards(User(),1254,45);
    Refresh(1098,1135,1175,1201,1254);
  }
}

# EndGameHook(player name who declared,result,result options,player numbers,player names,bet) - This
#   hook is called at the beginning of the game result
#   prosessing. Note: this hook is not called for undecided results.
#
def EndGameHook
{
  if(length(ARG[3])>1)
  {
    push(p);
    push(c);
    for(p)(ARG[4])
    {
      if(users{p}[4][1][0]==0)
      {
         if(!has_entry("reward",users{UserWithoutMode(p)}[3][0]))
           InitializeReward(p);
         RewardCard(UserWithoutMode(p),users{UserWithoutMode(p)}[3][0]{"reward"});
         
         c=random(300);
         if(c==297)
           RewardCard(UserWithoutMode(p),"COM");
         else if(c==298)
           RewardCard(UserWithoutMode(p),"PC2");
         else if(c==299)
           RewardCard(UserWithoutMode(p),"C13");
      }
    }
    c=pop();
    p=pop();
  }
}

#
# InitializeReward(player) - Set a player's reward set to the next one they need to complete.
#
def InitializeReward
{
  push(r);
  push(s);
  
  r="";
  for(s)(REWARD_ORDER)
  {
    if(r=="" && !count(s,users{UserWithoutMode(ARG)}[3][2]))
      r=s;
  } 
  
  if(r=="")
    r=s;
  
  users{UserWithoutMode(ARG)}[3][0]{"reward"} = r;
  
  s=pop();
  r=pop();
}

#
# RewardCard(player, set) - Give player a bonus card selected from the set.
#
def RewardCard
{
  push(p);
  push(c);
  push(s);
  push(ready);
  p=ARG[0];
  s=ARG[1];
  if(length(s)<1)
  {
    if(Con(p)>-1)
      Send(Con(p),("Message","{red}You were supposed to get a reward card for the game, but something bad happened. Contact a server administrator."));
    Log("Attempted to give "+p+" a reward card from bad set: "+tostr(s));
  }
  else
  {
    if(!has_entry(s,promo.booster))
      promo.booster{s} = (,);
  
    if(length(promo.booster{s})<1)
    {
      if(net_send(factory.server,(1,s,"booster")))
      {
        ready=0;
        while(!ready)
        {
          c=net_get();
          if(c!=NULL)
          {
            ready=1;
            promo.booster{s}=shuffle(flatten(toval(c[1])));
          }
        }
      }
      else
        Log("Factory server unavailable for handling reward request");
    }
  }
  
  if(length(promo.booster{s})<1)
    Send(Con(p),("Message","{blue}You were supposed to get a reward card for the game, but the supply of cards is unavailable. Sorry.");
  else
  {
    c=first(promo.booster{s});
    promo.booster{s}=tail(promo.booster{s});
    AddCard(p,c);
    SendAll("Message","{blue}"+p+" receives{gold} #"+c+"# {blue}as a reward for the game.");
    if(Con(p)>-1)
      Send(Con(p),("SetCardbook",((c,users{p}[2]{c}),)));
  }         
  ready=pop();
  s=pop();
  c=pop();
  p=pop();
}

#
# SetHook(setting name, value) - Called before checking a setting to apply. Return 0 if not handled.
#
def SetHook
{
  push(r);
  push(s);
  return(0);
  
  if(ARG[0]=="reward")
  {
    return(1);
    if(typeof(ARG[1])!="string")
    {
      if(!has_entry("reward",users{UserWithoutMode()}[3][0]))
        InitializeReward(UserWithoutMode());
      Reply("{green}You are currently set up to receive your reward cards from {yellow}"+users{UserWithoutMode()}[3][0]{"reward"}+"{green}.");
    }
    else
    {
      s=uc(ARG[1]);
      r=find(s,REWARD_ORDER);
  
      if(r != NULL)
      {
        push(f);
        f=0;
        
# a player can always collect a reward set they've already completed
        if(count(s,users{UserWithoutMode()}[3][2]))
          f=1;
# a player can always collect the first reward set
        else if(r==0)
          f=1;
# otherwise, a player can only collect a reward set if all the previous sets in line are registered
        else
        {
          for(s)(r)
          {
            if(count(REWARD_ORDER[s],users{UserWithoutMode()}[3][2]))
              f=f+1;
          }
          f=f/r;
        }
        
        if(f)
        {
          users{UserWithoutMode()}[3][0]{"reward"} = s;
          Reply("{green}The reward cards you receive after a game will now be from {yellow}"+s+"{green}.");
        }
        else
          Reply("{red}You still have other reward sets to collect before you can move on to that one.");
        f=pop();
      }
      else
        Reply("{red}That isn't a reward set. The reward sets are {yellow}"+join(REWARD_ORDER,", ")+"{red}, and they must be collected in that order.");
    }
  }
  
  s=pop();
  r=pop();
}

#
# RegisterHook(set) - Called after registering a set. Used for updating reward sets.
#
def RegisterHook
{
  push(i);
  
  i=find(ARG[0],REWARD_ORDER);
  
  if(i != NULL && i+1 < length(REWARD_ORDER))
  {
    users{User()}[3][0]{"reward"} = REWARD_ORDER[i+1];
    Reply("{green}The reward cards you receive after a game will now be from {yellow}"+REWARD_ORDER[i+1]+"{green}.");
    Reply("{green}If you still want to collect cards from the old set, you can use {yellow}/set reward "+REWARD_ORDER[i]+"{green}.");
  }
  
  i=pop();
}




command.acl{"/addvirtualproduct"}=(-1,("God","Salesman"));

#
# CommandAddvirtualproduct(num, virtual set code, type, price, name) - Implementation of the command /addvirtualproduct.
#  Adds a virtual product, which needs its own distribution or specific function.
#
def CommandAddvirtualproduct
{
  push(n);
  push(b);
  push(p);
  push(i);
  n=toint(ARG[0]);
  b=(ARG[1],ARG[2]);
  p=toreal(ARG[3]);
  if(length(ARG)>5)
    for(i)(length(ARG)-5)
      ARG[4]=ARG[4]+" "+ARG[5+i];
  if(n==0)
    Reply("{red}First argument must be > 0 (# of products).");
  else if(p <= 0.0)
    Reply("{red}Fourth argument must be > 0.0 (# price).");
  else if(length(ARG)<5)
    Reply("{red}Not enough arguments.");
  else
  {
    push(e);
    if(!has_entry(ARG[1],set.data))
    {
      i=ARG[4]+" "+ARG[2];
      if(has_entry(i,products))
        Reply("{red}Product already added.");
      else
      {
        e=(n,p,b,n);
        SendAll("Message","{green}New product "+i+" arrived!");
        products{i}=e;
        SendAll("SetProducts",products);
      }
    }
    else
      Reply("{red}"+ARG[1]+" is a valid product code. Use /addproduct instead.");
    e=pop();
  }
  i=pop();
  p=pop();
  b=pop();
  n=pop();
}